# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: Query
  subscription: Subscription
}

interface PoolEvent {
  block: BigInt!
  pool: Pool!
  timestamp: BigInt!
  transaction: Bytes!
}

interface TradeVolume {
  pool: Pool!
  timestamp: BigInt!
  volume: BigDecimal!
}

type Account {
  address: Bytes!
  gaugeWeightVotes(first: Int = 100, orderBy: GaugeWeightVote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GaugeWeightVote_filter): [GaugeWeightVote!]
  " Liquidity gauges this account contributed to "
  gauges(first: Int = 100, orderBy: GaugeLiquidity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GaugeLiquidity_filter): [GaugeLiquidity!]
  id: ID!
  proposalVotes(first: Int = 100, orderBy: ProposalVote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ProposalVote_filter): [ProposalVote!]
  " Proposal created by this account "
  proposals(first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Proposal_filter): [Proposal!]
}

type AddLiquidityEvent implements PoolEvent {
  block: BigInt!
  fees: [BigInt!]!
  id: ID!
  invariant: BigInt!
  pool: Pool!
  provider: Account!
  timestamp: BigInt!
  tokenAmounts: [BigInt!]!
  tokenSupply: BigInt!
  transaction: Bytes!
}

type AdminFeeChangelog implements PoolEvent {
  block: BigInt!
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  transaction: Bytes!
  value: BigDecimal!
}

type AmplificationCoeffChangelog implements PoolEvent {
  block: BigInt!
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  transaction: Bytes!
  value: BigInt!
}

type Coin {
  balance: BigDecimal!
  " Equals to: <pool_id>-<coin_index>"
  id: ID!
  " Coin index "
  index: Int!
  pool: Pool!
  " Exchange rate between this coin and the associated underlying coin within the pool "
  rate: BigDecimal!
  token: Token!
  underlying: UnderlyingCoin!
  updated: BigInt!
  updatedAtBlock: BigInt!
  updatedAtTransaction: Bytes!
}

type Contract {
  added: BigInt!
  addedAtBlock: BigInt!
  addedAtTransaction: Bytes!
  " Human-readable description "
  description: String
  id: ID!
  modified: BigInt!
  modifiedAtBlock: BigInt!
  modifiedAtTransaction: Bytes!
  versions(first: Int = 100, orderBy: ContractVersion_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ContractVersion_filter): [ContractVersion!]
}

type ContractVersion {
  added: BigInt!
  addedAtBlock: BigInt!
  addedAtTransaction: Bytes!
  address: Bytes!
  contract: Contract!
  id: ID!
  version: BigInt!
}

type DailyVolume implements TradeVolume {
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  volume: BigDecimal!
}

type Exchange implements PoolEvent {
  amountBought: BigDecimal!
  amountSold: BigDecimal!
  block: BigInt!
  buyer: Account!
  id: ID!
  pool: Pool!
  receiver: Account!
  timestamp: BigInt!
  tokenBought: Token!
  tokenSold: Token!
  transaction: Bytes!
}

type FeeChangelog implements PoolEvent {
  block: BigInt!
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  transaction: Bytes!
  value: BigDecimal!
}

type Gauge {
  address: Bytes!
  created: BigInt!
  createdAtBlock: BigInt!
  createdAtTransaction: Bytes!
  id: ID!
  pool: Pool
  type: GaugeType!
  weightVotes(first: Int = 100, orderBy: GaugeWeightVote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GaugeWeightVote_filter): [GaugeWeightVote!]
  weights(first: Int = 100, orderBy: GaugeWeight_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GaugeWeight_filter): [GaugeWeight!]
}

type GaugeDeposit {
  gauge: Gauge!
  id: ID!
  provider: Account!
  value: BigDecimal!
}

type GaugeLiquidity {
  block: BigInt!
  gauge: Gauge!
  id: ID!
  originalBalance: BigInt!
  originalSupply: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
  user: Account!
  workingBalance: BigInt!
  workingSupply: BigInt!
}

type GaugeTotalWeight {
  id: ID!
  time: BigInt!
  weight: BigDecimal!
}

type GaugeType {
  gaugeCount: BigInt!
  gauges(first: Int = 100, orderBy: Gauge_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Gauge_filter): [Gauge!]
  id: ID!
  name: String!
  weights(first: Int = 100, orderBy: GaugeTypeWeight_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GaugeTypeWeight_filter): [GaugeTypeWeight!]
}

type GaugeTypeWeight {
  id: ID!
  time: BigInt!
  type: GaugeType!
  weight: BigDecimal!
}

type GaugeWeight {
  gauge: Gauge!
  id: ID!
  time: BigInt!
  weight: BigDecimal!
}

type GaugeWeightVote {
  gauge: Gauge!
  id: ID!
  time: BigInt!
  user: Account!
  weight: BigDecimal!
}

type GaugeWithdraw {
  gauge: Gauge!
  id: ID!
  provider: Account!
  value: BigDecimal!
}

type HourlyVolume implements TradeVolume {
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  volume: BigDecimal!
}

type LpToken {
  address: Bytes!
  decimals: BigInt!
  gauge: Gauge
  id: ID!
  name: String
  pool: Pool
  symbol: String
}

type Pool {
  " Amplification coefficient multiplied by n * (n - 1) "
  A: BigInt
  addedAt: BigInt!
  addedAtBlock: BigInt!
  addedAtTransaction: Bytes!
  " Admin fee is represented as a percentage of the total fee collected on a swap "
  adminFee: BigDecimal
  " Reference asset type "
  assetType: AssetType
  " Number of coins composing the pool "
  coinCount: BigInt!
  " List of the swappable coins within the pool "
  coins(first: Int = 100, orderBy: Coin_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Coin_filter): [Coin!]
  " Cumulative daily trade volume "
  dailyVolumes(first: Int = 100, orderBy: DailyVolume_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DailyVolume_filter): [DailyVolume!]
  events(first: Int = 100, orderBy: PoolEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolEvent_filter): [PoolEvent!]
  exchangeCount: BigInt!
  exchanges(first: Int = 100, orderBy: Exchange_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Exchange_filter): [Exchange!]
  " Fee to charge for exchanges "
  fee: BigDecimal
  gaugeCount: BigInt!
  " List of gauge contracts associated with the pool "
  gauges(first: Int = 100, orderBy: Gauge_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Gauge_filter): [Gauge!]
  " Cumulative hourly trade volume "
  hourlyVolumes(first: Int = 100, orderBy: HourlyVolume_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HourlyVolume_filter): [HourlyVolume!]
  " Pool address "
  id: ID!
  " Identify whether pool is a metapool "
  isMeta: Boolean!
  locked: BigDecimal!
  " Address of the token representing LP share "
  lpToken: LpToken!
  " Pool's human-readable name "
  name: String!
  " Admin address "
  owner: Bytes
  " Registry contract address from where this pool was registered "
  registryAddress: Bytes!
  removedAt: BigInt
  removedAtBlock: BigInt
  removedAtTransaction: Bytes
  " Swap contract address "
  swapAddress: Bytes!
  " List of the swappable underlying coins within the pool "
  underlyingCoins(first: Int = 100, orderBy: UnderlyingCoin_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: UnderlyingCoin_filter): [UnderlyingCoin!]
  " Number of underlying coins composing the pool "
  underlyingCount: BigInt!
  " Average dollar value of pool token "
  virtualPrice: BigDecimal!
  " Cumulative weekly trade volume "
  weeklyVolumes(first: Int = 100, orderBy: WeeklyVolume_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: WeeklyVolume_filter): [WeeklyVolume!]
}

type Proposal {
  " Voting app instance "
  app: VotingApp!
  created: BigInt!
  createdAtBlock: BigInt!
  createdAtTransaction: Bytes!
  " Proposal creator's account "
  creator: Account!
  currentQuorum: BigDecimal!
  currentSupport: BigDecimal!
  executed: BigInt
  executedAtBlock: BigInt
  executedAtTransaction: Bytes
  executionScript: Bytes!
  expireDate: BigInt!
  id: ID!
  " Link to metadata file "
  metadata: String
  " Percentage of positive votes in total possible votes for this proposal to be accepted "
  minimumQuorum: BigDecimal!
  " Number of negative votes (no) received by the proposal "
  negativeVoteCount: BigInt!
  " Sequential number in related to the realted voting app "
  number: BigInt!
  " Number of positive votes (yes) received by the proposal "
  positiveVoteCount: BigInt!
  " Percentage of positive votes needed for this proposal to be accepted "
  requiredSupport: BigDecimal!
  snapshotBlock: BigInt!
  stakedSupport: BigDecimal!
  " Proposal description text "
  text: String
  totalStaked: BigDecimal!
  updated: BigInt
  updatedAtBlock: BigInt
  updatedAtTransaction: Bytes
  " Number of votes received by the proposal "
  voteCount: BigInt!
  votes(first: Int = 100, orderBy: ProposalVote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ProposalVote_filter): [ProposalVote!]
  votingPower: BigDecimal!
}

type ProposalVote {
  created: BigInt!
  createdAtBlock: BigInt!
  createdAtTransaction: Bytes!
  id: ID!
  proposal: Proposal!
  stake: BigDecimal!
  supports: Boolean!
  voter: Account!
}

type Query {
  "Access to subgraph metadata"
  _meta(block: Block_height): _Meta_
  account(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Account_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Account_filter
  ): [Account!]!
  addLiquidityEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddLiquidityEvent
  addLiquidityEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: AddLiquidityEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: AddLiquidityEvent_filter
  ): [AddLiquidityEvent!]!
  adminFeeChangelog(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AdminFeeChangelog
  adminFeeChangelogs(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: AdminFeeChangelog_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: AdminFeeChangelog_filter
  ): [AdminFeeChangelog!]!
  amplificationCoeffChangelog(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AmplificationCoeffChangelog
  amplificationCoeffChangelogs(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: AmplificationCoeffChangelog_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: AmplificationCoeffChangelog_filter
  ): [AmplificationCoeffChangelog!]!
  coin(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Coin
  coins(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Coin_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Coin_filter
  ): [Coin!]!
  contract(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Contract
  contractVersion(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ContractVersion
  contractVersions(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: ContractVersion_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: ContractVersion_filter
  ): [ContractVersion!]!
  contracts(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Contract_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Contract_filter
  ): [Contract!]!
  dailyVolume(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyVolume
  dailyVolumes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: DailyVolume_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: DailyVolume_filter
  ): [DailyVolume!]!
  exchange(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Exchange
  exchanges(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Exchange_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Exchange_filter
  ): [Exchange!]!
  feeChangelog(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeChangelog
  feeChangelogs(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: FeeChangelog_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: FeeChangelog_filter
  ): [FeeChangelog!]!
  gauge(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Gauge
  gaugeDeposit(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeDeposit
  gaugeDeposits(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeDeposit_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeDeposit_filter
  ): [GaugeDeposit!]!
  gaugeLiquidities(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeLiquidity_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeLiquidity_filter
  ): [GaugeLiquidity!]!
  gaugeLiquidity(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeLiquidity
  gaugeTotalWeight(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeTotalWeight
  gaugeTotalWeights(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeTotalWeight_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeTotalWeight_filter
  ): [GaugeTotalWeight!]!
  gaugeType(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeType
  gaugeTypeWeight(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeTypeWeight
  gaugeTypeWeights(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeTypeWeight_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeTypeWeight_filter
  ): [GaugeTypeWeight!]!
  gaugeTypes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeType_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeType_filter
  ): [GaugeType!]!
  gaugeWeight(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeWeight
  gaugeWeightVote(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeWeightVote
  gaugeWeightVotes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeWeightVote_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeWeightVote_filter
  ): [GaugeWeightVote!]!
  gaugeWeights(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeWeight_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeWeight_filter
  ): [GaugeWeight!]!
  gaugeWithdraw(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeWithdraw
  gaugeWithdraws(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeWithdraw_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeWithdraw_filter
  ): [GaugeWithdraw!]!
  gauges(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Gauge_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Gauge_filter
  ): [Gauge!]!
  hourlyVolume(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HourlyVolume
  hourlyVolumes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: HourlyVolume_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: HourlyVolume_filter
  ): [HourlyVolume!]!
  lpToken(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LpToken
  lpTokens(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: LpToken_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: LpToken_filter
  ): [LpToken!]!
  pool(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolEvent
  poolEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: PoolEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: PoolEvent_filter
  ): [PoolEvent!]!
  pools(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Pool_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Pool_filter
  ): [Pool!]!
  proposal(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposalVote(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalVote
  proposalVotes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: ProposalVote_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: ProposalVote_filter
  ): [ProposalVote!]!
  proposals(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Proposal_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Proposal_filter
  ): [Proposal!]!
  removeLiquidityEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveLiquidityEvent
  removeLiquidityEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: RemoveLiquidityEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: RemoveLiquidityEvent_filter
  ): [RemoveLiquidityEvent!]!
  removeLiquidityOneEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveLiquidityOneEvent
  removeLiquidityOneEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: RemoveLiquidityOneEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: RemoveLiquidityOneEvent_filter
  ): [RemoveLiquidityOneEvent!]!
  systemState(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SystemState
  systemStates(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: SystemState_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: SystemState_filter
  ): [SystemState!]!
  token(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Token_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Token_filter
  ): [Token!]!
  tradeVolume(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeVolume
  tradeVolumes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: TradeVolume_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: TradeVolume_filter
  ): [TradeVolume!]!
  transferOwnershipEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferOwnershipEvent
  transferOwnershipEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: TransferOwnershipEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: TransferOwnershipEvent_filter
  ): [TransferOwnershipEvent!]!
  underlyingCoin(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnderlyingCoin
  underlyingCoins(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: UnderlyingCoin_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: UnderlyingCoin_filter
  ): [UnderlyingCoin!]!
  votingApp(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VotingApp
  votingApps(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: VotingApp_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: VotingApp_filter
  ): [VotingApp!]!
  weeklyVolume(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WeeklyVolume
  weeklyVolumes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: WeeklyVolume_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: WeeklyVolume_filter
  ): [WeeklyVolume!]!
}

type RemoveLiquidityEvent implements PoolEvent {
  block: BigInt!
  fees: [BigInt!]
  id: ID!
  invariant: BigInt
  pool: Pool!
  provider: Account!
  timestamp: BigInt!
  tokenAmounts: [BigInt!]!
  tokenSupply: BigInt
  transaction: Bytes!
}

type RemoveLiquidityOneEvent implements PoolEvent {
  block: BigInt!
  coinAmount: BigInt!
  id: ID!
  pool: Pool!
  provider: Account!
  timestamp: BigInt!
  tokenAmount: BigInt!
  transaction: Bytes!
}

type Subscription {
  "Access to subgraph metadata"
  _meta(block: Block_height): _Meta_
  account(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Account_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Account_filter
  ): [Account!]!
  addLiquidityEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddLiquidityEvent
  addLiquidityEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: AddLiquidityEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: AddLiquidityEvent_filter
  ): [AddLiquidityEvent!]!
  adminFeeChangelog(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AdminFeeChangelog
  adminFeeChangelogs(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: AdminFeeChangelog_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: AdminFeeChangelog_filter
  ): [AdminFeeChangelog!]!
  amplificationCoeffChangelog(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AmplificationCoeffChangelog
  amplificationCoeffChangelogs(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: AmplificationCoeffChangelog_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: AmplificationCoeffChangelog_filter
  ): [AmplificationCoeffChangelog!]!
  coin(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Coin
  coins(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Coin_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Coin_filter
  ): [Coin!]!
  contract(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Contract
  contractVersion(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ContractVersion
  contractVersions(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: ContractVersion_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: ContractVersion_filter
  ): [ContractVersion!]!
  contracts(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Contract_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Contract_filter
  ): [Contract!]!
  dailyVolume(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyVolume
  dailyVolumes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: DailyVolume_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: DailyVolume_filter
  ): [DailyVolume!]!
  exchange(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Exchange
  exchanges(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Exchange_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Exchange_filter
  ): [Exchange!]!
  feeChangelog(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeChangelog
  feeChangelogs(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: FeeChangelog_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: FeeChangelog_filter
  ): [FeeChangelog!]!
  gauge(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Gauge
  gaugeDeposit(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeDeposit
  gaugeDeposits(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeDeposit_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeDeposit_filter
  ): [GaugeDeposit!]!
  gaugeLiquidities(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeLiquidity_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeLiquidity_filter
  ): [GaugeLiquidity!]!
  gaugeLiquidity(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeLiquidity
  gaugeTotalWeight(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeTotalWeight
  gaugeTotalWeights(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeTotalWeight_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeTotalWeight_filter
  ): [GaugeTotalWeight!]!
  gaugeType(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeType
  gaugeTypeWeight(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeTypeWeight
  gaugeTypeWeights(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeTypeWeight_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeTypeWeight_filter
  ): [GaugeTypeWeight!]!
  gaugeTypes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeType_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeType_filter
  ): [GaugeType!]!
  gaugeWeight(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeWeight
  gaugeWeightVote(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeWeightVote
  gaugeWeightVotes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeWeightVote_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeWeightVote_filter
  ): [GaugeWeightVote!]!
  gaugeWeights(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeWeight_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeWeight_filter
  ): [GaugeWeight!]!
  gaugeWithdraw(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeWithdraw
  gaugeWithdraws(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: GaugeWithdraw_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: GaugeWithdraw_filter
  ): [GaugeWithdraw!]!
  gauges(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Gauge_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Gauge_filter
  ): [Gauge!]!
  hourlyVolume(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HourlyVolume
  hourlyVolumes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: HourlyVolume_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: HourlyVolume_filter
  ): [HourlyVolume!]!
  lpToken(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LpToken
  lpTokens(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: LpToken_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: LpToken_filter
  ): [LpToken!]!
  pool(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolEvent
  poolEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: PoolEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: PoolEvent_filter
  ): [PoolEvent!]!
  pools(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Pool_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Pool_filter
  ): [Pool!]!
  proposal(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposalVote(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalVote
  proposalVotes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: ProposalVote_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: ProposalVote_filter
  ): [ProposalVote!]!
  proposals(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Proposal_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Proposal_filter
  ): [Proposal!]!
  removeLiquidityEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveLiquidityEvent
  removeLiquidityEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: RemoveLiquidityEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: RemoveLiquidityEvent_filter
  ): [RemoveLiquidityEvent!]!
  removeLiquidityOneEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveLiquidityOneEvent
  removeLiquidityOneEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: RemoveLiquidityOneEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: RemoveLiquidityOneEvent_filter
  ): [RemoveLiquidityOneEvent!]!
  systemState(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SystemState
  systemStates(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: SystemState_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: SystemState_filter
  ): [SystemState!]!
  token(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Token_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Token_filter
  ): [Token!]!
  tradeVolume(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeVolume
  tradeVolumes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: TradeVolume_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: TradeVolume_filter
  ): [TradeVolume!]!
  transferOwnershipEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferOwnershipEvent
  transferOwnershipEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: TransferOwnershipEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: TransferOwnershipEvent_filter
  ): [TransferOwnershipEvent!]!
  underlyingCoin(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnderlyingCoin
  underlyingCoins(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: UnderlyingCoin_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: UnderlyingCoin_filter
  ): [UnderlyingCoin!]!
  votingApp(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VotingApp
  votingApps(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: VotingApp_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: VotingApp_filter
  ): [VotingApp!]!
  weeklyVolume(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WeeklyVolume
  weeklyVolumes(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: WeeklyVolume_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: WeeklyVolume_filter
  ): [WeeklyVolume!]!
}

type SystemState {
  " Number of contracts in the AddressProvider registry "
  contractCount: BigInt!
  " Number of gauges registered "
  gaugeCount: BigInt!
  " Number of gauge types registered "
  gaugeTypeCount: BigInt!
  " Singleton ID, equals to 'current' "
  id: ID!
  " Number of active pools "
  poolCount: BigInt!
  " Current pool registry address "
  registryContract: Bytes
  " Number of tokens registered "
  tokenCount: BigInt!
  " Total number of pools (including removed ones) "
  totalPoolCount: BigInt!
  updated: BigInt!
  updatedAtBlock: BigInt!
  updatedAtTransaction: Bytes!
}

type Token {
  address: Bytes!
  coins(first: Int = 100, orderBy: Coin_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Coin_filter): [Coin!]
  decimals: BigInt!
  id: ID!
  name: String
  pools(first: Int = 100, orderBy: Pool_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Pool_filter): [Pool!]
  symbol: String
  underlyingCoins(first: Int = 100, orderBy: UnderlyingCoin_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: UnderlyingCoin_filter): [UnderlyingCoin!]
}

type TransferOwnershipEvent implements PoolEvent {
  block: BigInt!
  id: ID!
  newAdmin: Bytes!
  pool: Pool!
  timestamp: BigInt!
  transaction: Bytes!
}

type UnderlyingCoin {
  balance: BigDecimal!
  coin: Coin!
  " Equals to: <pool_id>-<coin_index>"
  id: ID!
  " Coin index "
  index: Int!
  pool: Pool!
  token: Token!
  updated: BigInt!
  updatedAtBlock: BigInt!
  updatedAtTransaction: Bytes!
}

type VotingApp {
  " Voting app instance "
  address: Bytes!
  " App codename "
  codename: String!
  " Equals to app address "
  id: ID!
  " Minimum balance needed to create a proposal "
  minimumBalance: BigDecimal!
  " Percentage of positive votes in total possible votes for a proposal to be accepted "
  minimumQuorum: BigDecimal!
  " Minimum time needed to pass between user's previous proposal and a user creating a new proposal "
  minimumTime: BigInt!
  " Number of proposals created with this app "
  proposalCount: BigInt!
  " Proposals created through this app instance "
  proposals(first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Proposal_filter): [Proposal!]
  " Percentage of positive votes needed for a proposal to be accepted "
  requiredSupport: BigDecimal!
  " Address of the token used for voting "
  token: Bytes!
  " Number of votes received by all the proposals created with this app "
  voteCount: BigInt!
  " Seconds that a proposal will be open for vote (unless enough votes have been cast to make an early decision) "
  voteTime: BigInt!
}

type WeeklyVolume implements TradeVolume {
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  volume: BigDecimal!
}

type _Block_ {
  "The hash of the block"
  hash: Bytes
  "The block number"
  number: Int!
}

"The type for the top-level _meta field"
type _Meta_ {
  """

  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!
  "The deployment ID"
  deployment: String!
  "If `true`, the subgraph encountered indexing errors at some past block"
  hasIndexingErrors: Boolean!
}

enum Account_orderBy {
  address
  gaugeWeightVotes
  gauges
  id
  proposalVotes
  proposals
}

enum AddLiquidityEvent_orderBy {
  block
  fees
  id
  invariant
  pool
  provider
  timestamp
  tokenAmounts
  tokenSupply
  transaction
}

enum AdminFeeChangelog_orderBy {
  block
  id
  pool
  timestamp
  transaction
  value
}

enum AmplificationCoeffChangelog_orderBy {
  block
  id
  pool
  timestamp
  transaction
  value
}

enum AssetType {
  BTC
  CRYPTO
  ETH
  EUR
  LINK
  OTHER
  USD
}

enum Coin_orderBy {
  balance
  id
  index
  pool
  rate
  token
  underlying
  updated
  updatedAtBlock
  updatedAtTransaction
}

enum ContractVersion_orderBy {
  added
  addedAtBlock
  addedAtTransaction
  address
  contract
  id
  version
}

enum Contract_orderBy {
  added
  addedAtBlock
  addedAtTransaction
  description
  id
  modified
  modifiedAtBlock
  modifiedAtTransaction
  versions
}

enum DailyVolume_orderBy {
  id
  pool
  timestamp
  volume
}

enum Exchange_orderBy {
  amountBought
  amountSold
  block
  buyer
  id
  pool
  receiver
  timestamp
  tokenBought
  tokenSold
  transaction
}

enum FeeChangelog_orderBy {
  block
  id
  pool
  timestamp
  transaction
  value
}

enum GaugeDeposit_orderBy {
  gauge
  id
  provider
  value
}

enum GaugeLiquidity_orderBy {
  block
  gauge
  id
  originalBalance
  originalSupply
  timestamp
  transaction
  user
  workingBalance
  workingSupply
}

enum GaugeTotalWeight_orderBy {
  id
  time
  weight
}

enum GaugeTypeWeight_orderBy {
  id
  time
  type
  weight
}

enum GaugeType_orderBy {
  gaugeCount
  gauges
  id
  name
  weights
}

enum GaugeWeightVote_orderBy {
  gauge
  id
  time
  user
  weight
}

enum GaugeWeight_orderBy {
  gauge
  id
  time
  weight
}

enum GaugeWithdraw_orderBy {
  gauge
  id
  provider
  value
}

enum Gauge_orderBy {
  address
  created
  createdAtBlock
  createdAtTransaction
  id
  pool
  type
  weightVotes
  weights
}

enum HourlyVolume_orderBy {
  id
  pool
  timestamp
  volume
}

enum LpToken_orderBy {
  address
  decimals
  gauge
  id
  name
  pool
  symbol
}

enum OrderDirection {
  asc
  desc
}

enum PoolEvent_orderBy {
  block
  pool
  timestamp
  transaction
}

enum Pool_orderBy {
  A
  addedAt
  addedAtBlock
  addedAtTransaction
  adminFee
  assetType
  coinCount
  coins
  dailyVolumes
  events
  exchangeCount
  exchanges
  fee
  gaugeCount
  gauges
  hourlyVolumes
  id
  isMeta
  locked
  lpToken
  name
  owner
  registryAddress
  removedAt
  removedAtBlock
  removedAtTransaction
  swapAddress
  underlyingCoins
  underlyingCount
  virtualPrice
  weeklyVolumes
}

enum ProposalVote_orderBy {
  created
  createdAtBlock
  createdAtTransaction
  id
  proposal
  stake
  supports
  voter
}

enum Proposal_orderBy {
  app
  created
  createdAtBlock
  createdAtTransaction
  creator
  currentQuorum
  currentSupport
  executed
  executedAtBlock
  executedAtTransaction
  executionScript
  expireDate
  id
  metadata
  minimumQuorum
  negativeVoteCount
  number
  positiveVoteCount
  requiredSupport
  snapshotBlock
  stakedSupport
  text
  totalStaked
  updated
  updatedAtBlock
  updatedAtTransaction
  voteCount
  votes
  votingPower
}

enum RemoveLiquidityEvent_orderBy {
  block
  fees
  id
  invariant
  pool
  provider
  timestamp
  tokenAmounts
  tokenSupply
  transaction
}

enum RemoveLiquidityOneEvent_orderBy {
  block
  coinAmount
  id
  pool
  provider
  timestamp
  tokenAmount
  transaction
}

enum SystemState_orderBy {
  contractCount
  gaugeCount
  gaugeTypeCount
  id
  poolCount
  registryContract
  tokenCount
  totalPoolCount
  updated
  updatedAtBlock
  updatedAtTransaction
}

enum Token_orderBy {
  address
  coins
  decimals
  id
  name
  pools
  symbol
  underlyingCoins
}

enum TradeVolume_orderBy {
  pool
  timestamp
  volume
}

enum TransferOwnershipEvent_orderBy {
  block
  id
  newAdmin
  pool
  timestamp
  transaction
}

enum UnderlyingCoin_orderBy {
  balance
  coin
  id
  index
  pool
  token
  updated
  updatedAtBlock
  updatedAtTransaction
}

enum VotingApp_orderBy {
  address
  codename
  id
  minimumBalance
  minimumQuorum
  minimumTime
  proposalCount
  proposals
  requiredSupport
  token
  voteCount
  voteTime
}

enum WeeklyVolume_orderBy {
  id
  pool
  timestamp
  volume
}

enum _SubgraphErrorPolicy_ {
  "Data will be returned even if the subgraph has indexing errors"
  allow
  "If the subgraph has indexing errors, data will be omitted. The default."
  deny
}

input Account_filter {
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
}

input AddLiquidityEvent_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  fees: [BigInt!]
  fees_contains: [BigInt!]
  fees_not: [BigInt!]
  fees_not_contains: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  invariant: BigInt
  invariant_gt: BigInt
  invariant_gte: BigInt
  invariant_in: [BigInt!]
  invariant_lt: BigInt
  invariant_lte: BigInt
  invariant_not: BigInt
  invariant_not_in: [BigInt!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  provider: String
  provider_contains: String
  provider_ends_with: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_ends_with: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  tokenAmounts: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenSupply: BigInt
  tokenSupply_gt: BigInt
  tokenSupply_gte: BigInt
  tokenSupply_in: [BigInt!]
  tokenSupply_lt: BigInt
  tokenSupply_lte: BigInt
  tokenSupply_not: BigInt
  tokenSupply_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
}

input AdminFeeChangelog_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

input AmplificationCoeffChangelog_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input Coin_filter {
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
  underlying: String
  underlying_contains: String
  underlying_ends_with: String
  underlying_gt: String
  underlying_gte: String
  underlying_in: [String!]
  underlying_lt: String
  underlying_lte: String
  underlying_not: String
  underlying_not_contains: String
  underlying_not_ends_with: String
  underlying_not_in: [String!]
  underlying_not_starts_with: String
  underlying_starts_with: String
  updated: BigInt
  updatedAtBlock: BigInt
  updatedAtBlock_gt: BigInt
  updatedAtBlock_gte: BigInt
  updatedAtBlock_in: [BigInt!]
  updatedAtBlock_lt: BigInt
  updatedAtBlock_lte: BigInt
  updatedAtBlock_not: BigInt
  updatedAtBlock_not_in: [BigInt!]
  updatedAtTransaction: Bytes
  updatedAtTransaction_contains: Bytes
  updatedAtTransaction_in: [Bytes!]
  updatedAtTransaction_not: Bytes
  updatedAtTransaction_not_contains: Bytes
  updatedAtTransaction_not_in: [Bytes!]
  updated_gt: BigInt
  updated_gte: BigInt
  updated_in: [BigInt!]
  updated_lt: BigInt
  updated_lte: BigInt
  updated_not: BigInt
  updated_not_in: [BigInt!]
}

input ContractVersion_filter {
  added: BigInt
  addedAtBlock: BigInt
  addedAtBlock_gt: BigInt
  addedAtBlock_gte: BigInt
  addedAtBlock_in: [BigInt!]
  addedAtBlock_lt: BigInt
  addedAtBlock_lte: BigInt
  addedAtBlock_not: BigInt
  addedAtBlock_not_in: [BigInt!]
  addedAtTransaction: Bytes
  addedAtTransaction_contains: Bytes
  addedAtTransaction_in: [Bytes!]
  addedAtTransaction_not: Bytes
  addedAtTransaction_not_contains: Bytes
  addedAtTransaction_not_in: [Bytes!]
  added_gt: BigInt
  added_gte: BigInt
  added_in: [BigInt!]
  added_lt: BigInt
  added_lte: BigInt
  added_not: BigInt
  added_not_in: [BigInt!]
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  contract: String
  contract_contains: String
  contract_ends_with: String
  contract_gt: String
  contract_gte: String
  contract_in: [String!]
  contract_lt: String
  contract_lte: String
  contract_not: String
  contract_not_contains: String
  contract_not_ends_with: String
  contract_not_in: [String!]
  contract_not_starts_with: String
  contract_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  version: BigInt
  version_gt: BigInt
  version_gte: BigInt
  version_in: [BigInt!]
  version_lt: BigInt
  version_lte: BigInt
  version_not: BigInt
  version_not_in: [BigInt!]
}

input Contract_filter {
  added: BigInt
  addedAtBlock: BigInt
  addedAtBlock_gt: BigInt
  addedAtBlock_gte: BigInt
  addedAtBlock_in: [BigInt!]
  addedAtBlock_lt: BigInt
  addedAtBlock_lte: BigInt
  addedAtBlock_not: BigInt
  addedAtBlock_not_in: [BigInt!]
  addedAtTransaction: Bytes
  addedAtTransaction_contains: Bytes
  addedAtTransaction_in: [Bytes!]
  addedAtTransaction_not: Bytes
  addedAtTransaction_not_contains: Bytes
  addedAtTransaction_not_in: [Bytes!]
  added_gt: BigInt
  added_gte: BigInt
  added_in: [BigInt!]
  added_lt: BigInt
  added_lte: BigInt
  added_not: BigInt
  added_not_in: [BigInt!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  modified: BigInt
  modifiedAtBlock: BigInt
  modifiedAtBlock_gt: BigInt
  modifiedAtBlock_gte: BigInt
  modifiedAtBlock_in: [BigInt!]
  modifiedAtBlock_lt: BigInt
  modifiedAtBlock_lte: BigInt
  modifiedAtBlock_not: BigInt
  modifiedAtBlock_not_in: [BigInt!]
  modifiedAtTransaction: Bytes
  modifiedAtTransaction_contains: Bytes
  modifiedAtTransaction_in: [Bytes!]
  modifiedAtTransaction_not: Bytes
  modifiedAtTransaction_not_contains: Bytes
  modifiedAtTransaction_not_in: [Bytes!]
  modified_gt: BigInt
  modified_gte: BigInt
  modified_in: [BigInt!]
  modified_lt: BigInt
  modified_lte: BigInt
  modified_not: BigInt
  modified_not_in: [BigInt!]
}

input DailyVolume_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  volume: BigDecimal
  volume_gt: BigDecimal
  volume_gte: BigDecimal
  volume_in: [BigDecimal!]
  volume_lt: BigDecimal
  volume_lte: BigDecimal
  volume_not: BigDecimal
  volume_not_in: [BigDecimal!]
}

input Exchange_filter {
  amountBought: BigDecimal
  amountBought_gt: BigDecimal
  amountBought_gte: BigDecimal
  amountBought_in: [BigDecimal!]
  amountBought_lt: BigDecimal
  amountBought_lte: BigDecimal
  amountBought_not: BigDecimal
  amountBought_not_in: [BigDecimal!]
  amountSold: BigDecimal
  amountSold_gt: BigDecimal
  amountSold_gte: BigDecimal
  amountSold_in: [BigDecimal!]
  amountSold_lt: BigDecimal
  amountSold_lte: BigDecimal
  amountSold_not: BigDecimal
  amountSold_not_in: [BigDecimal!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  buyer: String
  buyer_contains: String
  buyer_ends_with: String
  buyer_gt: String
  buyer_gte: String
  buyer_in: [String!]
  buyer_lt: String
  buyer_lte: String
  buyer_not: String
  buyer_not_contains: String
  buyer_not_ends_with: String
  buyer_not_in: [String!]
  buyer_not_starts_with: String
  buyer_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  receiver: String
  receiver_contains: String
  receiver_ends_with: String
  receiver_gt: String
  receiver_gte: String
  receiver_in: [String!]
  receiver_lt: String
  receiver_lte: String
  receiver_not: String
  receiver_not_contains: String
  receiver_not_ends_with: String
  receiver_not_in: [String!]
  receiver_not_starts_with: String
  receiver_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  tokenBought: String
  tokenBought_contains: String
  tokenBought_ends_with: String
  tokenBought_gt: String
  tokenBought_gte: String
  tokenBought_in: [String!]
  tokenBought_lt: String
  tokenBought_lte: String
  tokenBought_not: String
  tokenBought_not_contains: String
  tokenBought_not_ends_with: String
  tokenBought_not_in: [String!]
  tokenBought_not_starts_with: String
  tokenBought_starts_with: String
  tokenSold: String
  tokenSold_contains: String
  tokenSold_ends_with: String
  tokenSold_gt: String
  tokenSold_gte: String
  tokenSold_in: [String!]
  tokenSold_lt: String
  tokenSold_lte: String
  tokenSold_not: String
  tokenSold_not_contains: String
  tokenSold_not_ends_with: String
  tokenSold_not_in: [String!]
  tokenSold_not_starts_with: String
  tokenSold_starts_with: String
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
}

input FeeChangelog_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

input GaugeDeposit_filter {
  gauge: String
  gauge_contains: String
  gauge_ends_with: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_ends_with: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  provider: String
  provider_contains: String
  provider_ends_with: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_ends_with: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_starts_with: String
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

input GaugeLiquidity_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  gauge: String
  gauge_contains: String
  gauge_ends_with: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_ends_with: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  originalBalance: BigInt
  originalBalance_gt: BigInt
  originalBalance_gte: BigInt
  originalBalance_in: [BigInt!]
  originalBalance_lt: BigInt
  originalBalance_lte: BigInt
  originalBalance_not: BigInt
  originalBalance_not_in: [BigInt!]
  originalSupply: BigInt
  originalSupply_gt: BigInt
  originalSupply_gte: BigInt
  originalSupply_in: [BigInt!]
  originalSupply_lt: BigInt
  originalSupply_lte: BigInt
  originalSupply_not: BigInt
  originalSupply_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
  workingBalance: BigInt
  workingBalance_gt: BigInt
  workingBalance_gte: BigInt
  workingBalance_in: [BigInt!]
  workingBalance_lt: BigInt
  workingBalance_lte: BigInt
  workingBalance_not: BigInt
  workingBalance_not_in: [BigInt!]
  workingSupply: BigInt
  workingSupply_gt: BigInt
  workingSupply_gte: BigInt
  workingSupply_in: [BigInt!]
  workingSupply_lt: BigInt
  workingSupply_lte: BigInt
  workingSupply_not: BigInt
  workingSupply_not_in: [BigInt!]
}

input GaugeTotalWeight_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  weight: BigDecimal
  weight_gt: BigDecimal
  weight_gte: BigDecimal
  weight_in: [BigDecimal!]
  weight_lt: BigDecimal
  weight_lte: BigDecimal
  weight_not: BigDecimal
  weight_not_in: [BigDecimal!]
}

input GaugeTypeWeight_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  type: String
  type_contains: String
  type_ends_with: String
  type_gt: String
  type_gte: String
  type_in: [String!]
  type_lt: String
  type_lte: String
  type_not: String
  type_not_contains: String
  type_not_ends_with: String
  type_not_in: [String!]
  type_not_starts_with: String
  type_starts_with: String
  weight: BigDecimal
  weight_gt: BigDecimal
  weight_gte: BigDecimal
  weight_in: [BigDecimal!]
  weight_lt: BigDecimal
  weight_lte: BigDecimal
  weight_not: BigDecimal
  weight_not_in: [BigDecimal!]
}

input GaugeType_filter {
  gaugeCount: BigInt
  gaugeCount_gt: BigInt
  gaugeCount_gte: BigInt
  gaugeCount_in: [BigInt!]
  gaugeCount_lt: BigInt
  gaugeCount_lte: BigInt
  gaugeCount_not: BigInt
  gaugeCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
}

input GaugeWeightVote_filter {
  gauge: String
  gauge_contains: String
  gauge_ends_with: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_ends_with: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
  weight: BigDecimal
  weight_gt: BigDecimal
  weight_gte: BigDecimal
  weight_in: [BigDecimal!]
  weight_lt: BigDecimal
  weight_lte: BigDecimal
  weight_not: BigDecimal
  weight_not_in: [BigDecimal!]
}

input GaugeWeight_filter {
  gauge: String
  gauge_contains: String
  gauge_ends_with: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_ends_with: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  weight: BigDecimal
  weight_gt: BigDecimal
  weight_gte: BigDecimal
  weight_in: [BigDecimal!]
  weight_lt: BigDecimal
  weight_lte: BigDecimal
  weight_not: BigDecimal
  weight_not_in: [BigDecimal!]
}

input GaugeWithdraw_filter {
  gauge: String
  gauge_contains: String
  gauge_ends_with: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_ends_with: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  provider: String
  provider_contains: String
  provider_ends_with: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_ends_with: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_starts_with: String
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

input Gauge_filter {
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  created: BigInt
  createdAtBlock: BigInt
  createdAtBlock_gt: BigInt
  createdAtBlock_gte: BigInt
  createdAtBlock_in: [BigInt!]
  createdAtBlock_lt: BigInt
  createdAtBlock_lte: BigInt
  createdAtBlock_not: BigInt
  createdAtBlock_not_in: [BigInt!]
  createdAtTransaction: Bytes
  createdAtTransaction_contains: Bytes
  createdAtTransaction_in: [Bytes!]
  createdAtTransaction_not: Bytes
  createdAtTransaction_not_contains: Bytes
  createdAtTransaction_not_in: [Bytes!]
  created_gt: BigInt
  created_gte: BigInt
  created_in: [BigInt!]
  created_lt: BigInt
  created_lte: BigInt
  created_not: BigInt
  created_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  type: String
  type_contains: String
  type_ends_with: String
  type_gt: String
  type_gte: String
  type_in: [String!]
  type_lt: String
  type_lte: String
  type_not: String
  type_not_contains: String
  type_not_ends_with: String
  type_not_in: [String!]
  type_not_starts_with: String
  type_starts_with: String
}

input HourlyVolume_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  volume: BigDecimal
  volume_gt: BigDecimal
  volume_gte: BigDecimal
  volume_in: [BigDecimal!]
  volume_lt: BigDecimal
  volume_lte: BigDecimal
  volume_not: BigDecimal
  volume_not_in: [BigDecimal!]
}

input LpToken_filter {
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  decimals: BigInt
  decimals_gt: BigInt
  decimals_gte: BigInt
  decimals_in: [BigInt!]
  decimals_lt: BigInt
  decimals_lte: BigInt
  decimals_not: BigInt
  decimals_not_in: [BigInt!]
  gauge: String
  gauge_contains: String
  gauge_ends_with: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_ends_with: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  symbol: String
  symbol_contains: String
  symbol_ends_with: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_ends_with: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_starts_with: String
}

input PoolEvent_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
}

input Pool_filter {
  A: BigInt
  A_gt: BigInt
  A_gte: BigInt
  A_in: [BigInt!]
  A_lt: BigInt
  A_lte: BigInt
  A_not: BigInt
  A_not_in: [BigInt!]
  addedAt: BigInt
  addedAtBlock: BigInt
  addedAtBlock_gt: BigInt
  addedAtBlock_gte: BigInt
  addedAtBlock_in: [BigInt!]
  addedAtBlock_lt: BigInt
  addedAtBlock_lte: BigInt
  addedAtBlock_not: BigInt
  addedAtBlock_not_in: [BigInt!]
  addedAtTransaction: Bytes
  addedAtTransaction_contains: Bytes
  addedAtTransaction_in: [Bytes!]
  addedAtTransaction_not: Bytes
  addedAtTransaction_not_contains: Bytes
  addedAtTransaction_not_in: [Bytes!]
  addedAt_gt: BigInt
  addedAt_gte: BigInt
  addedAt_in: [BigInt!]
  addedAt_lt: BigInt
  addedAt_lte: BigInt
  addedAt_not: BigInt
  addedAt_not_in: [BigInt!]
  adminFee: BigDecimal
  adminFee_gt: BigDecimal
  adminFee_gte: BigDecimal
  adminFee_in: [BigDecimal!]
  adminFee_lt: BigDecimal
  adminFee_lte: BigDecimal
  adminFee_not: BigDecimal
  adminFee_not_in: [BigDecimal!]
  assetType: AssetType
  assetType_in: [AssetType!]
  assetType_not: AssetType
  assetType_not_in: [AssetType!]
  coinCount: BigInt
  coinCount_gt: BigInt
  coinCount_gte: BigInt
  coinCount_in: [BigInt!]
  coinCount_lt: BigInt
  coinCount_lte: BigInt
  coinCount_not: BigInt
  coinCount_not_in: [BigInt!]
  exchangeCount: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_lt: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_not: BigInt
  exchangeCount_not_in: [BigInt!]
  fee: BigDecimal
  fee_gt: BigDecimal
  fee_gte: BigDecimal
  fee_in: [BigDecimal!]
  fee_lt: BigDecimal
  fee_lte: BigDecimal
  fee_not: BigDecimal
  fee_not_in: [BigDecimal!]
  gaugeCount: BigInt
  gaugeCount_gt: BigInt
  gaugeCount_gte: BigInt
  gaugeCount_in: [BigInt!]
  gaugeCount_lt: BigInt
  gaugeCount_lte: BigInt
  gaugeCount_not: BigInt
  gaugeCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isMeta: Boolean
  isMeta_in: [Boolean!]
  isMeta_not: Boolean
  isMeta_not_in: [Boolean!]
  locked: BigDecimal
  locked_gt: BigDecimal
  locked_gte: BigDecimal
  locked_in: [BigDecimal!]
  locked_lt: BigDecimal
  locked_lte: BigDecimal
  locked_not: BigDecimal
  locked_not_in: [BigDecimal!]
  lpToken: String
  lpToken_contains: String
  lpToken_ends_with: String
  lpToken_gt: String
  lpToken_gte: String
  lpToken_in: [String!]
  lpToken_lt: String
  lpToken_lte: String
  lpToken_not: String
  lpToken_not_contains: String
  lpToken_not_ends_with: String
  lpToken_not_in: [String!]
  lpToken_not_starts_with: String
  lpToken_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  owner: Bytes
  owner_contains: Bytes
  owner_in: [Bytes!]
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  registryAddress: Bytes
  registryAddress_contains: Bytes
  registryAddress_in: [Bytes!]
  registryAddress_not: Bytes
  registryAddress_not_contains: Bytes
  registryAddress_not_in: [Bytes!]
  removedAt: BigInt
  removedAtBlock: BigInt
  removedAtBlock_gt: BigInt
  removedAtBlock_gte: BigInt
  removedAtBlock_in: [BigInt!]
  removedAtBlock_lt: BigInt
  removedAtBlock_lte: BigInt
  removedAtBlock_not: BigInt
  removedAtBlock_not_in: [BigInt!]
  removedAtTransaction: Bytes
  removedAtTransaction_contains: Bytes
  removedAtTransaction_in: [Bytes!]
  removedAtTransaction_not: Bytes
  removedAtTransaction_not_contains: Bytes
  removedAtTransaction_not_in: [Bytes!]
  removedAt_gt: BigInt
  removedAt_gte: BigInt
  removedAt_in: [BigInt!]
  removedAt_lt: BigInt
  removedAt_lte: BigInt
  removedAt_not: BigInt
  removedAt_not_in: [BigInt!]
  swapAddress: Bytes
  swapAddress_contains: Bytes
  swapAddress_in: [Bytes!]
  swapAddress_not: Bytes
  swapAddress_not_contains: Bytes
  swapAddress_not_in: [Bytes!]
  underlyingCount: BigInt
  underlyingCount_gt: BigInt
  underlyingCount_gte: BigInt
  underlyingCount_in: [BigInt!]
  underlyingCount_lt: BigInt
  underlyingCount_lte: BigInt
  underlyingCount_not: BigInt
  underlyingCount_not_in: [BigInt!]
  virtualPrice: BigDecimal
  virtualPrice_gt: BigDecimal
  virtualPrice_gte: BigDecimal
  virtualPrice_in: [BigDecimal!]
  virtualPrice_lt: BigDecimal
  virtualPrice_lte: BigDecimal
  virtualPrice_not: BigDecimal
  virtualPrice_not_in: [BigDecimal!]
}

input ProposalVote_filter {
  created: BigInt
  createdAtBlock: BigInt
  createdAtBlock_gt: BigInt
  createdAtBlock_gte: BigInt
  createdAtBlock_in: [BigInt!]
  createdAtBlock_lt: BigInt
  createdAtBlock_lte: BigInt
  createdAtBlock_not: BigInt
  createdAtBlock_not_in: [BigInt!]
  createdAtTransaction: Bytes
  createdAtTransaction_contains: Bytes
  createdAtTransaction_in: [Bytes!]
  createdAtTransaction_not: Bytes
  createdAtTransaction_not_contains: Bytes
  createdAtTransaction_not_in: [Bytes!]
  created_gt: BigInt
  created_gte: BigInt
  created_in: [BigInt!]
  created_lt: BigInt
  created_lte: BigInt
  created_not: BigInt
  created_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  proposal: String
  proposal_contains: String
  proposal_ends_with: String
  proposal_gt: String
  proposal_gte: String
  proposal_in: [String!]
  proposal_lt: String
  proposal_lte: String
  proposal_not: String
  proposal_not_contains: String
  proposal_not_ends_with: String
  proposal_not_in: [String!]
  proposal_not_starts_with: String
  proposal_starts_with: String
  stake: BigDecimal
  stake_gt: BigDecimal
  stake_gte: BigDecimal
  stake_in: [BigDecimal!]
  stake_lt: BigDecimal
  stake_lte: BigDecimal
  stake_not: BigDecimal
  stake_not_in: [BigDecimal!]
  supports: Boolean
  supports_in: [Boolean!]
  supports_not: Boolean
  supports_not_in: [Boolean!]
  voter: String
  voter_contains: String
  voter_ends_with: String
  voter_gt: String
  voter_gte: String
  voter_in: [String!]
  voter_lt: String
  voter_lte: String
  voter_not: String
  voter_not_contains: String
  voter_not_ends_with: String
  voter_not_in: [String!]
  voter_not_starts_with: String
  voter_starts_with: String
}

input Proposal_filter {
  app: String
  app_contains: String
  app_ends_with: String
  app_gt: String
  app_gte: String
  app_in: [String!]
  app_lt: String
  app_lte: String
  app_not: String
  app_not_contains: String
  app_not_ends_with: String
  app_not_in: [String!]
  app_not_starts_with: String
  app_starts_with: String
  created: BigInt
  createdAtBlock: BigInt
  createdAtBlock_gt: BigInt
  createdAtBlock_gte: BigInt
  createdAtBlock_in: [BigInt!]
  createdAtBlock_lt: BigInt
  createdAtBlock_lte: BigInt
  createdAtBlock_not: BigInt
  createdAtBlock_not_in: [BigInt!]
  createdAtTransaction: Bytes
  createdAtTransaction_contains: Bytes
  createdAtTransaction_in: [Bytes!]
  createdAtTransaction_not: Bytes
  createdAtTransaction_not_contains: Bytes
  createdAtTransaction_not_in: [Bytes!]
  created_gt: BigInt
  created_gte: BigInt
  created_in: [BigInt!]
  created_lt: BigInt
  created_lte: BigInt
  created_not: BigInt
  created_not_in: [BigInt!]
  creator: String
  creator_contains: String
  creator_ends_with: String
  creator_gt: String
  creator_gte: String
  creator_in: [String!]
  creator_lt: String
  creator_lte: String
  creator_not: String
  creator_not_contains: String
  creator_not_ends_with: String
  creator_not_in: [String!]
  creator_not_starts_with: String
  creator_starts_with: String
  currentQuorum: BigDecimal
  currentQuorum_gt: BigDecimal
  currentQuorum_gte: BigDecimal
  currentQuorum_in: [BigDecimal!]
  currentQuorum_lt: BigDecimal
  currentQuorum_lte: BigDecimal
  currentQuorum_not: BigDecimal
  currentQuorum_not_in: [BigDecimal!]
  currentSupport: BigDecimal
  currentSupport_gt: BigDecimal
  currentSupport_gte: BigDecimal
  currentSupport_in: [BigDecimal!]
  currentSupport_lt: BigDecimal
  currentSupport_lte: BigDecimal
  currentSupport_not: BigDecimal
  currentSupport_not_in: [BigDecimal!]
  executed: BigInt
  executedAtBlock: BigInt
  executedAtBlock_gt: BigInt
  executedAtBlock_gte: BigInt
  executedAtBlock_in: [BigInt!]
  executedAtBlock_lt: BigInt
  executedAtBlock_lte: BigInt
  executedAtBlock_not: BigInt
  executedAtBlock_not_in: [BigInt!]
  executedAtTransaction: Bytes
  executedAtTransaction_contains: Bytes
  executedAtTransaction_in: [Bytes!]
  executedAtTransaction_not: Bytes
  executedAtTransaction_not_contains: Bytes
  executedAtTransaction_not_in: [Bytes!]
  executed_gt: BigInt
  executed_gte: BigInt
  executed_in: [BigInt!]
  executed_lt: BigInt
  executed_lte: BigInt
  executed_not: BigInt
  executed_not_in: [BigInt!]
  executionScript: Bytes
  executionScript_contains: Bytes
  executionScript_in: [Bytes!]
  executionScript_not: Bytes
  executionScript_not_contains: Bytes
  executionScript_not_in: [Bytes!]
  expireDate: BigInt
  expireDate_gt: BigInt
  expireDate_gte: BigInt
  expireDate_in: [BigInt!]
  expireDate_lt: BigInt
  expireDate_lte: BigInt
  expireDate_not: BigInt
  expireDate_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  metadata: String
  metadata_contains: String
  metadata_ends_with: String
  metadata_gt: String
  metadata_gte: String
  metadata_in: [String!]
  metadata_lt: String
  metadata_lte: String
  metadata_not: String
  metadata_not_contains: String
  metadata_not_ends_with: String
  metadata_not_in: [String!]
  metadata_not_starts_with: String
  metadata_starts_with: String
  minimumQuorum: BigDecimal
  minimumQuorum_gt: BigDecimal
  minimumQuorum_gte: BigDecimal
  minimumQuorum_in: [BigDecimal!]
  minimumQuorum_lt: BigDecimal
  minimumQuorum_lte: BigDecimal
  minimumQuorum_not: BigDecimal
  minimumQuorum_not_in: [BigDecimal!]
  negativeVoteCount: BigInt
  negativeVoteCount_gt: BigInt
  negativeVoteCount_gte: BigInt
  negativeVoteCount_in: [BigInt!]
  negativeVoteCount_lt: BigInt
  negativeVoteCount_lte: BigInt
  negativeVoteCount_not: BigInt
  negativeVoteCount_not_in: [BigInt!]
  number: BigInt
  number_gt: BigInt
  number_gte: BigInt
  number_in: [BigInt!]
  number_lt: BigInt
  number_lte: BigInt
  number_not: BigInt
  number_not_in: [BigInt!]
  positiveVoteCount: BigInt
  positiveVoteCount_gt: BigInt
  positiveVoteCount_gte: BigInt
  positiveVoteCount_in: [BigInt!]
  positiveVoteCount_lt: BigInt
  positiveVoteCount_lte: BigInt
  positiveVoteCount_not: BigInt
  positiveVoteCount_not_in: [BigInt!]
  requiredSupport: BigDecimal
  requiredSupport_gt: BigDecimal
  requiredSupport_gte: BigDecimal
  requiredSupport_in: [BigDecimal!]
  requiredSupport_lt: BigDecimal
  requiredSupport_lte: BigDecimal
  requiredSupport_not: BigDecimal
  requiredSupport_not_in: [BigDecimal!]
  snapshotBlock: BigInt
  snapshotBlock_gt: BigInt
  snapshotBlock_gte: BigInt
  snapshotBlock_in: [BigInt!]
  snapshotBlock_lt: BigInt
  snapshotBlock_lte: BigInt
  snapshotBlock_not: BigInt
  snapshotBlock_not_in: [BigInt!]
  stakedSupport: BigDecimal
  stakedSupport_gt: BigDecimal
  stakedSupport_gte: BigDecimal
  stakedSupport_in: [BigDecimal!]
  stakedSupport_lt: BigDecimal
  stakedSupport_lte: BigDecimal
  stakedSupport_not: BigDecimal
  stakedSupport_not_in: [BigDecimal!]
  text: String
  text_contains: String
  text_ends_with: String
  text_gt: String
  text_gte: String
  text_in: [String!]
  text_lt: String
  text_lte: String
  text_not: String
  text_not_contains: String
  text_not_ends_with: String
  text_not_in: [String!]
  text_not_starts_with: String
  text_starts_with: String
  totalStaked: BigDecimal
  totalStaked_gt: BigDecimal
  totalStaked_gte: BigDecimal
  totalStaked_in: [BigDecimal!]
  totalStaked_lt: BigDecimal
  totalStaked_lte: BigDecimal
  totalStaked_not: BigDecimal
  totalStaked_not_in: [BigDecimal!]
  updated: BigInt
  updatedAtBlock: BigInt
  updatedAtBlock_gt: BigInt
  updatedAtBlock_gte: BigInt
  updatedAtBlock_in: [BigInt!]
  updatedAtBlock_lt: BigInt
  updatedAtBlock_lte: BigInt
  updatedAtBlock_not: BigInt
  updatedAtBlock_not_in: [BigInt!]
  updatedAtTransaction: Bytes
  updatedAtTransaction_contains: Bytes
  updatedAtTransaction_in: [Bytes!]
  updatedAtTransaction_not: Bytes
  updatedAtTransaction_not_contains: Bytes
  updatedAtTransaction_not_in: [Bytes!]
  updated_gt: BigInt
  updated_gte: BigInt
  updated_in: [BigInt!]
  updated_lt: BigInt
  updated_lte: BigInt
  updated_not: BigInt
  updated_not_in: [BigInt!]
  voteCount: BigInt
  voteCount_gt: BigInt
  voteCount_gte: BigInt
  voteCount_in: [BigInt!]
  voteCount_lt: BigInt
  voteCount_lte: BigInt
  voteCount_not: BigInt
  voteCount_not_in: [BigInt!]
  votingPower: BigDecimal
  votingPower_gt: BigDecimal
  votingPower_gte: BigDecimal
  votingPower_in: [BigDecimal!]
  votingPower_lt: BigDecimal
  votingPower_lte: BigDecimal
  votingPower_not: BigDecimal
  votingPower_not_in: [BigDecimal!]
}

input RemoveLiquidityEvent_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  fees: [BigInt!]
  fees_contains: [BigInt!]
  fees_not: [BigInt!]
  fees_not_contains: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  invariant: BigInt
  invariant_gt: BigInt
  invariant_gte: BigInt
  invariant_in: [BigInt!]
  invariant_lt: BigInt
  invariant_lte: BigInt
  invariant_not: BigInt
  invariant_not_in: [BigInt!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  provider: String
  provider_contains: String
  provider_ends_with: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_ends_with: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  tokenAmounts: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenSupply: BigInt
  tokenSupply_gt: BigInt
  tokenSupply_gte: BigInt
  tokenSupply_in: [BigInt!]
  tokenSupply_lt: BigInt
  tokenSupply_lte: BigInt
  tokenSupply_not: BigInt
  tokenSupply_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
}

input RemoveLiquidityOneEvent_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  coinAmount: BigInt
  coinAmount_gt: BigInt
  coinAmount_gte: BigInt
  coinAmount_in: [BigInt!]
  coinAmount_lt: BigInt
  coinAmount_lte: BigInt
  coinAmount_not: BigInt
  coinAmount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  provider: String
  provider_contains: String
  provider_ends_with: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_ends_with: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  tokenAmount: BigInt
  tokenAmount_gt: BigInt
  tokenAmount_gte: BigInt
  tokenAmount_in: [BigInt!]
  tokenAmount_lt: BigInt
  tokenAmount_lte: BigInt
  tokenAmount_not: BigInt
  tokenAmount_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
}

input SystemState_filter {
  contractCount: BigInt
  contractCount_gt: BigInt
  contractCount_gte: BigInt
  contractCount_in: [BigInt!]
  contractCount_lt: BigInt
  contractCount_lte: BigInt
  contractCount_not: BigInt
  contractCount_not_in: [BigInt!]
  gaugeCount: BigInt
  gaugeCount_gt: BigInt
  gaugeCount_gte: BigInt
  gaugeCount_in: [BigInt!]
  gaugeCount_lt: BigInt
  gaugeCount_lte: BigInt
  gaugeCount_not: BigInt
  gaugeCount_not_in: [BigInt!]
  gaugeTypeCount: BigInt
  gaugeTypeCount_gt: BigInt
  gaugeTypeCount_gte: BigInt
  gaugeTypeCount_in: [BigInt!]
  gaugeTypeCount_lt: BigInt
  gaugeTypeCount_lte: BigInt
  gaugeTypeCount_not: BigInt
  gaugeTypeCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolCount: BigInt
  poolCount_gt: BigInt
  poolCount_gte: BigInt
  poolCount_in: [BigInt!]
  poolCount_lt: BigInt
  poolCount_lte: BigInt
  poolCount_not: BigInt
  poolCount_not_in: [BigInt!]
  registryContract: Bytes
  registryContract_contains: Bytes
  registryContract_in: [Bytes!]
  registryContract_not: Bytes
  registryContract_not_contains: Bytes
  registryContract_not_in: [Bytes!]
  tokenCount: BigInt
  tokenCount_gt: BigInt
  tokenCount_gte: BigInt
  tokenCount_in: [BigInt!]
  tokenCount_lt: BigInt
  tokenCount_lte: BigInt
  tokenCount_not: BigInt
  tokenCount_not_in: [BigInt!]
  totalPoolCount: BigInt
  totalPoolCount_gt: BigInt
  totalPoolCount_gte: BigInt
  totalPoolCount_in: [BigInt!]
  totalPoolCount_lt: BigInt
  totalPoolCount_lte: BigInt
  totalPoolCount_not: BigInt
  totalPoolCount_not_in: [BigInt!]
  updated: BigInt
  updatedAtBlock: BigInt
  updatedAtBlock_gt: BigInt
  updatedAtBlock_gte: BigInt
  updatedAtBlock_in: [BigInt!]
  updatedAtBlock_lt: BigInt
  updatedAtBlock_lte: BigInt
  updatedAtBlock_not: BigInt
  updatedAtBlock_not_in: [BigInt!]
  updatedAtTransaction: Bytes
  updatedAtTransaction_contains: Bytes
  updatedAtTransaction_in: [Bytes!]
  updatedAtTransaction_not: Bytes
  updatedAtTransaction_not_contains: Bytes
  updatedAtTransaction_not_in: [Bytes!]
  updated_gt: BigInt
  updated_gte: BigInt
  updated_in: [BigInt!]
  updated_lt: BigInt
  updated_lte: BigInt
  updated_not: BigInt
  updated_not_in: [BigInt!]
}

input Token_filter {
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  decimals: BigInt
  decimals_gt: BigInt
  decimals_gte: BigInt
  decimals_in: [BigInt!]
  decimals_lt: BigInt
  decimals_lte: BigInt
  decimals_not: BigInt
  decimals_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  pools: [String!]
  pools_contains: [String!]
  pools_not: [String!]
  pools_not_contains: [String!]
  symbol: String
  symbol_contains: String
  symbol_ends_with: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_ends_with: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_starts_with: String
}

input TradeVolume_filter {
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  volume: BigDecimal
  volume_gt: BigDecimal
  volume_gte: BigDecimal
  volume_in: [BigDecimal!]
  volume_lt: BigDecimal
  volume_lte: BigDecimal
  volume_not: BigDecimal
  volume_not_in: [BigDecimal!]
}

input TransferOwnershipEvent_filter {
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  newAdmin: Bytes
  newAdmin_contains: Bytes
  newAdmin_in: [Bytes!]
  newAdmin_not: Bytes
  newAdmin_not_contains: Bytes
  newAdmin_not_in: [Bytes!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_in: [Bytes!]
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
}

input UnderlyingCoin_filter {
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  coin: String
  coin_contains: String
  coin_ends_with: String
  coin_gt: String
  coin_gte: String
  coin_in: [String!]
  coin_lt: String
  coin_lte: String
  coin_not: String
  coin_not_contains: String
  coin_not_ends_with: String
  coin_not_in: [String!]
  coin_not_starts_with: String
  coin_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
  updated: BigInt
  updatedAtBlock: BigInt
  updatedAtBlock_gt: BigInt
  updatedAtBlock_gte: BigInt
  updatedAtBlock_in: [BigInt!]
  updatedAtBlock_lt: BigInt
  updatedAtBlock_lte: BigInt
  updatedAtBlock_not: BigInt
  updatedAtBlock_not_in: [BigInt!]
  updatedAtTransaction: Bytes
  updatedAtTransaction_contains: Bytes
  updatedAtTransaction_in: [Bytes!]
  updatedAtTransaction_not: Bytes
  updatedAtTransaction_not_contains: Bytes
  updatedAtTransaction_not_in: [Bytes!]
  updated_gt: BigInt
  updated_gte: BigInt
  updated_in: [BigInt!]
  updated_lt: BigInt
  updated_lte: BigInt
  updated_not: BigInt
  updated_not_in: [BigInt!]
}

input VotingApp_filter {
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  codename: String
  codename_contains: String
  codename_ends_with: String
  codename_gt: String
  codename_gte: String
  codename_in: [String!]
  codename_lt: String
  codename_lte: String
  codename_not: String
  codename_not_contains: String
  codename_not_ends_with: String
  codename_not_in: [String!]
  codename_not_starts_with: String
  codename_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  minimumBalance: BigDecimal
  minimumBalance_gt: BigDecimal
  minimumBalance_gte: BigDecimal
  minimumBalance_in: [BigDecimal!]
  minimumBalance_lt: BigDecimal
  minimumBalance_lte: BigDecimal
  minimumBalance_not: BigDecimal
  minimumBalance_not_in: [BigDecimal!]
  minimumQuorum: BigDecimal
  minimumQuorum_gt: BigDecimal
  minimumQuorum_gte: BigDecimal
  minimumQuorum_in: [BigDecimal!]
  minimumQuorum_lt: BigDecimal
  minimumQuorum_lte: BigDecimal
  minimumQuorum_not: BigDecimal
  minimumQuorum_not_in: [BigDecimal!]
  minimumTime: BigInt
  minimumTime_gt: BigInt
  minimumTime_gte: BigInt
  minimumTime_in: [BigInt!]
  minimumTime_lt: BigInt
  minimumTime_lte: BigInt
  minimumTime_not: BigInt
  minimumTime_not_in: [BigInt!]
  proposalCount: BigInt
  proposalCount_gt: BigInt
  proposalCount_gte: BigInt
  proposalCount_in: [BigInt!]
  proposalCount_lt: BigInt
  proposalCount_lte: BigInt
  proposalCount_not: BigInt
  proposalCount_not_in: [BigInt!]
  requiredSupport: BigDecimal
  requiredSupport_gt: BigDecimal
  requiredSupport_gte: BigDecimal
  requiredSupport_in: [BigDecimal!]
  requiredSupport_lt: BigDecimal
  requiredSupport_lte: BigDecimal
  requiredSupport_not: BigDecimal
  requiredSupport_not_in: [BigDecimal!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  voteCount: BigInt
  voteCount_gt: BigInt
  voteCount_gte: BigInt
  voteCount_in: [BigInt!]
  voteCount_lt: BigInt
  voteCount_lte: BigInt
  voteCount_not: BigInt
  voteCount_not_in: [BigInt!]
  voteTime: BigInt
  voteTime_gt: BigInt
  voteTime_gte: BigInt
  voteTime_in: [BigInt!]
  voteTime_lt: BigInt
  voteTime_lte: BigInt
  voteTime_not: BigInt
  voteTime_not_in: [BigInt!]
}

input WeeklyVolume_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_ends_with: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_ends_with: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  volume: BigDecimal
  volume_gt: BigDecimal
  volume_gte: BigDecimal
  volume_in: [BigDecimal!]
  volume_lt: BigDecimal
  volume_lte: BigDecimal
  volume_not: BigDecimal
  volume_not_in: [BigDecimal!]
}


scalar BigDecimal

scalar BigInt

scalar Bytes
